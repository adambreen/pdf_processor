"""Tests for the PDF processor module.

This test suite validates the PDF processing functionality, with a particular
focus on table detection and processing. Tests are designed to work with the
sample PDF generated by generate_sample_pdf.py.

Table Detection Test Strategy:
----------------------------
1. Test Categories:
   - Border-based detection (primary method)
   - Alignment-based detection (fallback method)
   - Mixed detection scenarios
   - Edge cases and error handling

2. Current Test Coverage:
   - Basic table detection with borders
   - Column and row span handling
   - Text alignment detection
   - Header row recognition
   - Borderless table detection
   - Error cases (empty PDF, invalid PDF)

3. Adding New Tests:
   - First add corresponding table to generate_sample_pdf.py
   - Generate new sample PDF
   - Add test cases here that validate new features
   - Include both positive and negative test cases
   - Document test purpose and coverage

4. Known Limitations:
   - Partial border detection not fully tested
   - Complex nested tables not covered
   - Line opacity tests not implemented
   - Limited error case coverage

5. Future Test Additions:
   - Opacity handling tests
   - Nested table detection
   - Complex border styles
   - Performance tests for large documents
   - More edge cases and error conditions
"""

import pytest
from unittest.mock import patch
from pdf_processor import (
    Table,
    TableCell,
    TableMetrics,
    TextBlock,
    detect_tables,
    detect_tables_from_borders,
    detect_tables_from_alignment,
    table_to_markdown,
    is_potential_table_row,
    extract_text_with_metadata,
    extract_hyperlinks_with_pymupdf,
    extract_layout_with_pymupdf,
    layout_to_markdown,
)
import fitz
from pathlib import Path

# Sample test PDF paths
TEST_PDF_PATH = "tests/sample.pdf"
TEST_SCANNED_PDF_PATH = TEST_PDF_PATH  # Use same file for now


@pytest.fixture
def sample_text_blocks():
    """Create sample text blocks for testing."""
    return [
        TextBlock(
            text="Header",
            x0=10,
            y0=10,
            x1=100,
            y1=30,
            font_size=16,
            font="HeaderFont",
        ),
        TextBlock(
            text="Body text",
            x0=10,
            y0=50,
            x1=200,
            y1=70,
            font_size=12,
            font="BodyFont",
        ),
        TextBlock(
            text="Name Age",
            x0=10,
            y0=80,
            x1=200,
            y1=90,
            font_size=12,
            font="TableFont",
        ),
        TextBlock(
            text="Alice 30",
            x0=10,
            y0=100,
            x1=200,
            y1=120,
            font_size=12,
            font="TableFont",
        ),
    ]


@pytest.fixture
def mock_subprocess_run(monkeypatch):
    """Mock subprocess.run for tests."""
    def mock_run(*args, **kwargs):
        class MockResult:
            stdout = "Sample PDF content"
            stderr = ""
            returncode = 0
        return MockResult()
    
    with patch("subprocess.run", mock_run):
        yield


@pytest.fixture
def mock_dependencies(monkeypatch):
    """Mock dependency checks."""
    from pdf_processor.text import Result
    def mock_check():
        return Result.Ok(None)
    monkeypatch.setattr("pdf_processor.text.check_dependencies", mock_check)


def test_extract_text_with_metadata(mock_subprocess_run, mock_dependencies):
    """Test that text is correctly extracted from a PDF."""
    result = extract_text_with_metadata(TEST_PDF_PATH)
    assert result.is_ok
    text = result.value
    assert isinstance(text, str)
    assert len(text) > 0


def test_extract_hyperlinks_with_pymupdf():
    """Test that hyperlinks are correctly extracted from a PDF."""
    result = extract_hyperlinks_with_pymupdf(TEST_PDF_PATH)
    assert result.is_ok
    links = result.value
    assert isinstance(links, list)
    for text, url in links:
        assert isinstance(text, str)
        assert isinstance(url, str)
        assert url.startswith("http")


def test_extract_layout_with_pymupdf():
    """Test that layout-aware text blocks are extracted from a PDF."""
    result = extract_layout_with_pymupdf(TEST_PDF_PATH)
    assert result.is_ok
    blocks = result.value
    assert isinstance(blocks, list)
    for block in blocks:
        assert isinstance(block, TextBlock)
        assert isinstance(block.text, str)
        assert block.text.strip()


def test_layout_to_markdown(sample_text_blocks):
    """Test conversion of layout-aware text blocks to Markdown."""
    links = [("Header", "http://example.com")]
    markdown = layout_to_markdown(sample_text_blocks, links)
    assert isinstance(markdown, str)
    # Expect either a header or a link, but not both
    assert any(["# Header" in markdown, "[Header](http://example.com)" in markdown])
    assert "| Name | Age |" in markdown
    assert "| Alice | 30 |" in markdown


def test_scanned_pdf_handling(mock_subprocess_run, mock_dependencies):
    """Test that a scanned PDF without embedded text gracefully returns empty or runs OCR in the future."""
    result = extract_text_with_metadata(TEST_PDF_PATH)
    assert result.is_ok  # Should not raise an error
    text = result.value
    assert isinstance(text, str)  # Should return empty string for now


def test_detect_tables():
    """Test table detection."""
    table_metrics = TableMetrics()
    tables = detect_tables("tests/sample.pdf", table_metrics)
    assert len(tables) > 0
    assert isinstance(tables[0], Table)
    assert len(tables[0].cells) > 0
    assert len(tables[0].cells[0]) > 0
    assert isinstance(tables[0].cells[0][0], TableCell)


def test_table_to_markdown():
    """Test table to Markdown conversion."""
    table = Table()
    table.has_header = True
    
    # Add header row
    header_row = [
        TableCell("Header 1", is_header=True),
        TableCell("Header 2", is_header=True),
        TableCell("Header 3", is_header=True)
    ]
    table.cells.append(header_row)
    
    # Add data rows
    data_row1 = [
        TableCell("Row 1 Col 1"),
        TableCell("Row 1 Col 2"),
        TableCell("Row 1 Col 3")
    ]
    data_row2 = [
        TableCell("Row 2 Col 1"),
        TableCell("Row 2 Col 2"),
        TableCell("Row 2 Col 3")
    ]
    table.cells.extend([data_row1, data_row2])
    
    markdown = table_to_markdown(table)
    expected = (
        "| Header 1 | Header 2 | Header 3 |\n"
        "| :--- | :--- | :--- |\n"
        "| Row 1 Col 1 | Row 1 Col 2 | Row 1 Col 3 |\n"
        "| Row 2 Col 1 | Row 2 Col 2 | Row 2 Col 3 |"
    )
    
    assert markdown.strip() == expected


def test_detect_tables_from_borders():
    """Test table detection using borders."""
    import logging
    logging.basicConfig(level=logging.DEBUG)
    table_metrics = TableMetrics()
    doc = fitz.open("tests/sample.pdf")
    try:
        tables = detect_tables_from_borders(doc[0], table_metrics)
        assert len(tables) > 0
    finally:
        doc.close()


def test_detect_tables_from_alignment():
    """Test table detection using text alignment."""
    table_metrics = TableMetrics()
    doc = fitz.open("tests/sample.pdf")
    try:
        tables = detect_tables_from_alignment(doc[0], table_metrics)
        assert len(tables) > 0
    finally:
        doc.close()


def test_is_potential_table_row():
    """Test detection of potential table rows."""
    table_metrics = TableMetrics()
    text_blocks = [
        TextBlock(
            text="Name Age",
            x0=10,
            y0=80,
            x1=200,
            y1=90,
            font_size=12,
            font="TableFont",
        ),
        TextBlock(
            text="Alice 30",
            x0=10,
            y0=100,
            x1=200,
            y1=120,
            font_size=12,
            font="TableFont",
        ),
    ]
    
    # Test some blocks that should be table rows
    table_rows = [block for block in text_blocks if is_potential_table_row(block, table_metrics)]
    assert len(table_rows) > 0


def test_table_to_markdown_with_spans():
    """Test table to Markdown conversion with spans."""
    table = Table()
    table.has_header = True
    
    # Add header with colspan
    header_row = [
        TableCell("Spanning Header", col_span=3, is_header=True)
    ]
    table.cells.append(header_row)
    
    # Add subheader
    subheader_row = [
        TableCell("Name"),
        TableCell("Value"),
        TableCell("Note")
    ]
    table.cells.append(subheader_row)
    
    # Add data with rowspan
    data_row1 = [
        TableCell("Item", row_span=2),
        TableCell("Value 1"),
        TableCell("Note 1")
    ]
    data_row2 = [
        TableCell(""),  # Empty due to rowspan
        TableCell("Value 2"),
        TableCell("Note 2")
    ]
    table.cells.extend([data_row1, data_row2])
    
    markdown = table_to_markdown(table)
    expected = (
        "| Spanning Header | | |\n"
        "| :--- | :--- | :--- |\n"
        "| Name | Value | Note |\n"
        "| Item | Value 1 | Note 1 |\n"
        "| | Value 2 | Note 2 |"
    )
    
    assert markdown.strip() == expected


def test_table_to_markdown_with_formatted_text():
    """Test table to Markdown conversion with formatted text."""
    table = Table()
    table.has_header = True
    
    # Add header row
    header_row = [
        TableCell("Column 1", is_header=True),
        TableCell("Column 2", is_header=True, alignment="center"),
        TableCell("Column 3", is_header=True, alignment="right")
    ]
    table.cells.append(header_row)
    
    # Add data rows
    data_row1 = [
        TableCell("Left"),
        TableCell("Center", alignment="center"),
        TableCell("Right", alignment="right")
    ]
    data_row2 = [
        TableCell("**Bold**"),
        TableCell("*Italic*"),
        TableCell("***Both***")
    ]
    table.cells.extend([data_row1, data_row2])
    
    markdown = table_to_markdown(table)
    expected = (
        "| Column 1 | Column 2 | Column 3 |\n"
        "| :--- | :---: | ---: |\n"
        "| Left | Center | Right |\n"
        "| **Bold** | *Italic* | ***Both*** |"
    )
    
    assert markdown.strip() == expected


@pytest.mark.skip(reason="PyMuPDF doesn't support empty PDFs - to be fixed later")
def test_empty_pdf(tmp_path):
    """Test handling of empty PDFs."""
    # Create an empty PDF
    empty_pdf = tmp_path / "empty.pdf"
    doc = fitz.open()
    doc.save(str(empty_pdf))
    doc.close()
    
    table_metrics = TableMetrics()
    tables = detect_tables(str(empty_pdf), table_metrics)
    assert len(tables) == 0


def test_no_tables_pdf(tmp_path):
    """Test handling of PDFs without any tables."""
    # Create a PDF with just text
    no_tables_pdf = tmp_path / "no_tables.pdf"
    doc = fitz.open()
    page = doc.new_page()
    page.insert_text((50, 50), "This is a test document with no tables.")
    doc.save(str(no_tables_pdf))
    doc.close()
    
    table_metrics = TableMetrics()
    tables = detect_tables(str(no_tables_pdf), table_metrics)
    assert len(tables) == 0


def test_invalid_pdf():
    """Test handling of invalid PDF files."""
    with pytest.raises(Exception):
        table_metrics = TableMetrics()
        detect_tables("nonexistent.pdf", table_metrics)


def test_table_without_borders():
    """Test detection of tables without explicit borders."""
    table_metrics = TableMetrics()
    doc = fitz.open("tests/sample.pdf")
    try:
        tables = detect_tables_from_alignment(doc[0], table_metrics)
        assert len(tables) > 0
        # Verify that at least one table is detected based on text alignment
        table = tables[0]
        assert len(table.cells) > 0
        assert all(len(row) > 1 for row in table.cells)  # At least 2 columns
    finally:
        doc.close()


def test_overlapping_text():
    """Test handling of tables with overlapping text."""
    table_metrics = TableMetrics()
    doc = fitz.open("tests/sample.pdf")
    try:
        page = doc[0]
        # Add overlapping text
        page.insert_text((100, 100), "Overlapping Text")
        tables = detect_tables(doc, table_metrics)
        # Should still detect tables despite overlapping text
        assert len(tables) > 0
    finally:
        doc.close()


@pytest.mark.skip(reason="Partial border detection needs improvement - to be fixed later")
def test_partial_borders():
    """Test detection of tables with partial borders."""
    table_metrics = TableMetrics()
    doc = fitz.open()
    try:
        page = doc.new_page()
        # Draw a table with missing borders
        page.draw_line((50, 50), (200, 50))  # Top border
        page.draw_line((50, 50), (50, 100))  # Left border
        # Missing right and bottom borders
        
        # Add some text to make it look like a table
        page.insert_text((60, 70), "Cell 1")
        page.insert_text((120, 70), "Cell 2")
        
        tables = detect_tables_from_borders(page, table_metrics)
        # Should still detect the table structure
        assert len(tables) > 0
    finally:
        doc.close()


def test_parse_args_default():
    """Test argument parsing with default values."""
    from pdf_processor.main import parse_args
    
    args = parse_args(["/path/to/pdf"])
    assert args.pdf_path == "/path/to/pdf"
    assert not args.images
    assert not args.text
    assert not args.markdown
    assert not args.debug


def test_parse_args_all_flags():
    """Test argument parsing with all flags enabled."""
    from pdf_processor.main import parse_args
    
    args = parse_args(["-i", "-t", "-m", "-d", "/path/to/pdf"])
    assert args.pdf_path == "/path/to/pdf"
    assert args.images
    assert args.text
    assert args.markdown
    assert args.debug


def test_parse_args_invalid():
    """Test argument parsing with invalid input."""
    from pdf_processor.main import parse_args
    import pytest
    
    with pytest.raises(SystemExit):
        parse_args([])  # Missing required PDF path


def test_process_pdf_text_only(tmp_path, mock_dependencies, mock_subprocess_run):
    """Test PDF processing with text extraction only."""
    from pdf_processor.main import process_pdf
    
    # Create a test output directory
    output_dir = tmp_path / "output"
    output_dir.mkdir()
    
    result = process_pdf(
        TEST_PDF_PATH,
        output_dir=str(output_dir),
        extract_text_flag=True
    )
    
    assert result.is_ok
    assert len(result.value) == 1  # One output file
    assert result.value[0].suffix == ".txt"
    assert result.value[0].exists()


def test_process_pdf_all_outputs(tmp_path, mock_dependencies, mock_subprocess_run):
    """Test PDF processing with all output types."""
    from pdf_processor.main import process_pdf
    
    # Create a test output directory
    output_dir = tmp_path / "output"
    output_dir.mkdir()
    
    result = process_pdf(
        TEST_PDF_PATH,
        output_dir=str(output_dir),
        extract_images_flag=True,
        extract_text_flag=True,
        extract_markdown_flag=True
    )
    
    assert result.is_ok
    assert len(result.value) >= 2  # At least text and markdown files
    
    # Check file types
    extensions = {p.suffix for p in result.value}
    assert ".txt" in extensions
    assert ".md" in extensions


def test_process_pdf_invalid_output_dir():
    """Test PDF processing with invalid output directory."""
    from pdf_processor.main import process_pdf
    
    result = process_pdf(
        TEST_PDF_PATH,
        output_dir="/nonexistent/directory",
        extract_text_flag=True
    )
    
    assert not result.is_ok
    assert "directory" in str(result.error).lower()


def test_process_pdf_invalid_input():
    """Test PDF processing with invalid input file."""
    from pdf_processor.main import process_pdf
    
    result = process_pdf(
        "nonexistent.pdf",
        output_dir=".",
        extract_text_flag=True
    )
    
    assert not result.is_ok
    assert "file not found" in str(result.error).lower()
