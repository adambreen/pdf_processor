"""Tests for the PDF processor module.

This test suite validates the PDF processing functionality, with a particular
focus on table detection and processing. Tests are designed to work with the
sample PDF generated by generate_sample_pdf.py.

Table Detection Test Strategy:
----------------------------
1. Test Categories:
   - Border-based detection (primary method)
   - Alignment-based detection (fallback method)
   - Mixed detection scenarios
   - Edge cases and error handling

2. Current Test Coverage:
   - Basic table detection with borders
   - Column and row span handling
   - Text alignment detection
   - Header row recognition
   - Borderless table detection
   - Error cases (empty PDF, invalid PDF)

3. Adding New Tests:
   - First add corresponding table to generate_sample_pdf.py
   - Generate new sample PDF
   - Add test cases here that validate new features
   - Include both positive and negative test cases
   - Document test purpose and coverage

4. Known Limitations:
   - Partial border detection not fully tested
   - Complex nested tables not covered
   - Line opacity tests not implemented
   - Limited error case coverage

5. Future Test Additions:
   - Opacity handling tests
   - Nested table detection
   - Complex border styles
   - Performance tests for large documents
   - More edge cases and error conditions
"""

import pytest
from unittest.mock import patch
from pdf_processor import (
    Table,
    TableCell,
    TableMetrics,
    TextBlock,
    detect_tables,
    detect_tables_from_borders,
    detect_tables_from_alignment,
    table_to_markdown,
    is_potential_table_row,
    extract_text_with_metadata,
    extract_hyperlinks_with_pymupdf,
    extract_layout_with_pymupdf,
    layout_to_markdown,
)
import fitz
from pathlib import Path
from pdf_processor.errors import Result, ExternalToolError

# Sample test PDF paths
TEST_PDF_PATH = "tests/sample.pdf"
TEST_SCANNED_PDF_PATH = TEST_PDF_PATH  # Use same file for now


@pytest.fixture
def sample_text_blocks():
    """Create sample text blocks for testing."""
    return [
        TextBlock(
            text="Header",
            x0=10,
            y0=10,
            x1=100,
            y1=30,
            font_size=16,
            font="HeaderFont",
        ),
        TextBlock(
            text="Body text",
            x0=10,
            y0=50,
            x1=200,
            y1=70,
            font_size=12,
            font="BodyFont",
        ),
        TextBlock(
            text="Name Age",
            x0=10,
            y0=80,
            x1=200,
            y1=90,
            font_size=12,
            font="TableFont",
        ),
        TextBlock(
            text="Alice 30",
            x0=10,
            y0=100,
            x1=200,
            y1=120,
            font_size=12,
            font="TableFont",
        ),
    ]


@pytest.fixture
def mock_subprocess_run(monkeypatch):
    """Mock subprocess.run for tests."""
    def mock_run(*args, **kwargs):
        class MockResult:
            stdout = "Sample PDF content"
            stderr = ""
            returncode = 0
        return MockResult()
    
    with patch("subprocess.run", mock_run):
        yield


@pytest.fixture
def mock_dependencies(monkeypatch):
    """Mock dependency checks."""
    from pdf_processor.text import Result
    def mock_check():
        return Result.Ok(None)
    monkeypatch.setattr("pdf_processor.text.check_dependencies", mock_check)


def test_extract_text_with_metadata(mock_subprocess_run, mock_dependencies):
    """Test that text is correctly extracted from a PDF."""
    result = extract_text_with_metadata(TEST_PDF_PATH)
    assert result.is_ok
    text = result.value
    assert isinstance(text, str)
    assert len(text) > 0


def test_extract_hyperlinks_with_pymupdf():
    """Test that hyperlinks are correctly extracted from a PDF."""
    result = extract_hyperlinks_with_pymupdf(TEST_PDF_PATH)
    assert result.is_ok
    links = result.value
    assert isinstance(links, list)
    for text, url in links:
        assert isinstance(text, str)
        assert isinstance(url, str)
        assert url.startswith("http")


def test_extract_layout_with_pymupdf():
    """Test that layout-aware text blocks are extracted from a PDF."""
    result = extract_layout_with_pymupdf(TEST_PDF_PATH)
    assert result.is_ok
    blocks = result.value
    assert isinstance(blocks, list)
    for block in blocks:
        assert isinstance(block, TextBlock)
        assert isinstance(block.text, str)
        assert block.text.strip()


def test_layout_to_markdown(sample_text_blocks):
    """Test conversion of layout-aware text blocks to Markdown."""
    links = [("Header", "http://example.com")]
    markdown = layout_to_markdown(sample_text_blocks, links)
    assert isinstance(markdown, str)
    # Expect either a header or a link, but not both
    assert any(["# Header" in markdown, "[Header](http://example.com)" in markdown])
    assert "| Name | Age |" in markdown
    assert "| Alice | 30 |" in markdown


def test_scanned_pdf_handling(mock_subprocess_run, mock_dependencies):
    """Test that a scanned PDF without embedded text gracefully returns empty or runs OCR in the future."""
    result = extract_text_with_metadata(TEST_PDF_PATH)
    assert result.is_ok  # Should not raise an error
    text = result.value
    assert isinstance(text, str)  # Should return empty string for now


def test_detect_tables():
    """Test table detection."""
    table_metrics = TableMetrics()
    tables = detect_tables("tests/sample.pdf", table_metrics)
    assert len(tables) > 0
    assert isinstance(tables[0], Table)
    assert len(tables[0].cells) > 0
    assert len(tables[0].cells[0]) > 0
    assert isinstance(tables[0].cells[0][0], TableCell)


def test_table_to_markdown():
    """Test table to Markdown conversion."""
    table = Table()
    table.has_header = True
    
    # Add header row
    header_row = [
        TableCell("Header 1", is_header=True),
        TableCell("Header 2", is_header=True),
        TableCell("Header 3", is_header=True)
    ]
    table.cells.append(header_row)
    
    # Add data rows
    data_row1 = [
        TableCell("Row 1 Col 1"),
        TableCell("Row 1 Col 2"),
        TableCell("Row 1 Col 3")
    ]
    data_row2 = [
        TableCell("Row 2 Col 1"),
        TableCell("Row 2 Col 2"),
        TableCell("Row 2 Col 3")
    ]
    table.cells.extend([data_row1, data_row2])
    
    markdown = table_to_markdown(table)
    expected = (
        "| Header 1 | Header 2 | Header 3 |\n"
        "| :--- | :--- | :--- |\n"
        "| Row 1 Col 1 | Row 1 Col 2 | Row 1 Col 3 |\n"
        "| Row 2 Col 1 | Row 2 Col 2 | Row 2 Col 3 |"
    )
    
    assert markdown.strip() == expected


def test_detect_tables_from_borders():
    """Test table detection using borders."""
    import logging
    logging.basicConfig(level=logging.DEBUG)
    table_metrics = TableMetrics()
    doc = fitz.open("tests/sample.pdf")
    try:
        tables = detect_tables_from_borders(doc[0], table_metrics)
        assert len(tables) > 0
    finally:
        doc.close()


def test_detect_tables_from_alignment():
    """Test table detection using text alignment."""
    table_metrics = TableMetrics()
    doc = fitz.open("tests/sample.pdf")
    try:
        tables = detect_tables_from_alignment(doc[0], table_metrics)
        assert len(tables) > 0
    finally:
        doc.close()


def test_is_potential_table_row():
    """Test detection of potential table rows."""
    table_metrics = TableMetrics()
    text_blocks = [
        TextBlock(
            text="Name Age",
            x0=10,
            y0=80,
            x1=200,
            y1=90,
            font_size=12,
            font="TableFont",
        ),
        TextBlock(
            text="Alice 30",
            x0=10,
            y0=100,
            x1=200,
            y1=120,
            font_size=12,
            font="TableFont",
        ),
    ]
    
    # Test some blocks that should be table rows
    table_rows = [block for block in text_blocks if is_potential_table_row(block, table_metrics)]
    assert len(table_rows) > 0


def test_table_to_markdown_with_spans():
    """Test table to Markdown conversion with spans."""
    table = Table()
    table.has_header = True
    
    # Add header with colspan
    header_row = [
        TableCell("Spanning Header", col_span=3, is_header=True)
    ]
    table.cells.append(header_row)
    
    # Add subheader
    subheader_row = [
        TableCell("Name"),
        TableCell("Value"),
        TableCell("Note")
    ]
    table.cells.append(subheader_row)
    
    # Add data with rowspan
    data_row1 = [
        TableCell("Item", row_span=2),
        TableCell("Value 1"),
        TableCell("Note 1")
    ]
    data_row2 = [
        TableCell(""),  # Empty due to rowspan
        TableCell("Value 2"),
        TableCell("Note 2")
    ]
    table.cells.extend([data_row1, data_row2])
    
    markdown = table_to_markdown(table)
    expected = (
        "| Spanning Header | | |\n"
        "| :--- | :--- | :--- |\n"
        "| Name | Value | Note |\n"
        "| Item | Value 1 | Note 1 |\n"
        "| | Value 2 | Note 2 |"
    )
    
    assert markdown.strip() == expected


def test_table_to_markdown_with_formatted_text():
    """Test table to Markdown conversion with formatted text."""
    table = Table()
    table.has_header = True
    
    # Add header row
    header_row = [
        TableCell("Column 1", is_header=True),
        TableCell("Column 2", is_header=True, alignment="center"),
        TableCell("Column 3", is_header=True, alignment="right")
    ]
    table.cells.append(header_row)
    
    # Add data rows
    data_row1 = [
        TableCell("Left"),
        TableCell("Center", alignment="center"),
        TableCell("Right", alignment="right")
    ]
    data_row2 = [
        TableCell("**Bold**"),
        TableCell("*Italic*"),
        TableCell("***Both***")
    ]
    table.cells.extend([data_row1, data_row2])
    
    markdown = table_to_markdown(table)
    expected = (
        "| Column 1 | Column 2 | Column 3 |\n"
        "| :--- | :---: | ---: |\n"
        "| Left | Center | Right |\n"
        "| **Bold** | *Italic* | ***Both*** |"
    )
    
    assert markdown.strip() == expected


@pytest.mark.skip(reason="PyMuPDF doesn't support empty PDFs - to be fixed later")
def test_empty_pdf(tmp_path):
    """Test handling of empty PDFs."""
    # Create an empty PDF
    empty_pdf = tmp_path / "empty.pdf"
    doc = fitz.open()
    doc.save(str(empty_pdf))
    doc.close()
    
    table_metrics = TableMetrics()
    tables = detect_tables(str(empty_pdf), table_metrics)
    assert len(tables) == 0


def test_no_tables_pdf(tmp_path):
    """Test handling of PDFs without any tables."""
    # Create a PDF with just text
    no_tables_pdf = tmp_path / "no_tables.pdf"
    doc = fitz.open()
    page = doc.new_page()
    page.insert_text((50, 50), "This is a test document with no tables.")
    doc.save(str(no_tables_pdf))
    doc.close()
    
    table_metrics = TableMetrics()
    tables = detect_tables(str(no_tables_pdf), table_metrics)
    assert len(tables) == 0


def test_invalid_pdf():
    """Test handling of invalid PDF files."""
    with pytest.raises(Exception):
        table_metrics = TableMetrics()
        detect_tables("nonexistent.pdf", table_metrics)


def test_table_without_borders():
    """Test detection of tables without explicit borders."""
    table_metrics = TableMetrics()
    doc = fitz.open("tests/sample.pdf")
    try:
        tables = detect_tables_from_alignment(doc[0], table_metrics)
        assert len(tables) > 0
        # Verify that at least one table is detected based on text alignment
        table = tables[0]
        assert len(table.cells) > 0
        assert all(len(row) > 1 for row in table.cells)  # At least 2 columns
    finally:
        doc.close()


def test_overlapping_text():
    """Test handling of tables with overlapping text."""
    table_metrics = TableMetrics()
    doc = fitz.open("tests/sample.pdf")
    try:
        page = doc[0]
        # Add overlapping text
        page.insert_text((100, 100), "Overlapping Text")
        tables = detect_tables(doc, table_metrics)
        # Should still detect tables despite overlapping text
        assert len(tables) > 0
    finally:
        doc.close()


@pytest.mark.skip(reason="Partial border detection needs improvement - to be fixed later")
def test_partial_borders():
    """Test detection of tables with partial borders."""
    table_metrics = TableMetrics()
    doc = fitz.open()
    try:
        page = doc.new_page()
        # Draw a table with missing borders
        page.draw_line((50, 50), (200, 50))  # Top border
        page.draw_line((50, 50), (50, 100))  # Left border
        # Missing right and bottom borders
        
        # Add some text to make it look like a table
        page.insert_text((60, 70), "Cell 1")
        page.insert_text((120, 70), "Cell 2")
        
        tables = detect_tables_from_borders(page, table_metrics)
        # Should still detect the table structure
        assert len(tables) > 0
    finally:
        doc.close()


def test_parse_args_default():
    """Test argument parsing with default values.
    
    Verifies that when no arguments are provided:
    1. Directory defaults to current directory (".")
    2. Input pattern defaults to "*.pdf"
    3. Output directory defaults to None (will use input directory)
    4. All extraction flags are disabled by default
    5. Debug mode is disabled by default
    """
    from pdf_processor.main import parse_args
    
    args = parse_args([])
    assert args.dir == "."
    assert args.input == "*.pdf"
    assert args.output is None
    assert not args.extract_images
    assert not args.extract_text
    assert not args.extract_markdown
    assert not args.debug


def test_parse_args_all_flags():
    """Test argument parsing with all flags and options specified.
    
    Verifies that the parser correctly handles:
    1. Custom input directory path
    2. Specific file pattern for matching PDFs
    3. Custom output directory path
    4. All extraction flags (images, text, markdown)
    5. Debug mode flag
    
    This represents a maximal command-line invocation where all
    optional arguments are specified.
    """
    from pdf_processor.main import parse_args
    
    args = parse_args([
        "-dir", "/path/to/pdfs",
        "-input", "report*.pdf",
        "-output", "/path/to/output",
        "--extract-images",
        "--extract-text",
        "--extract-markdown",
        "-d"
    ])
    assert args.dir == "/path/to/pdfs"
    assert args.input == "report*.pdf"
    assert args.output == "/path/to/output"
    assert args.extract_images
    assert args.extract_text
    assert args.extract_markdown
    assert args.debug


def test_parse_args_relative_paths():
    """Test argument parsing with relative path arguments.
    
    Verifies that the parser accepts and preserves relative paths:
    1. Relative input directory (./docs)
    2. Simple wildcard pattern (*.pdf)
    3. Parent directory reference in output path (../output)
    
    This ensures the tool works with both absolute and relative paths,
    which is important for command-line usability.
    """
    from pdf_processor.main import parse_args
    
    args = parse_args([
        "-dir", "docs",
        "-input", "*.pdf",
        "-output", "../output"
    ])
    assert args.dir == "docs"
    assert args.input == "*.pdf"
    assert args.output == "../output"


def test_process_pdf_text_only(tmp_path, mock_dependencies, mock_subprocess_run):
    """Test basic text extraction from multiple PDFs.
    
    Tests the core text extraction functionality:
    1. Processes multiple PDFs in a directory
    2. Creates separate output directories for each PDF
    3. Names output files based on input PDF names
    4. Verifies all expected output files are created
    
    Directory structure created for test:
    input/
        test1.pdf
        test2.pdf
    output/
        test1/
            test1.txt
        test2/
            test2.txt
    """
    from pdf_processor.main import process_pdf
    
    # Create test input directory with sample PDFs
    input_dir = tmp_path / "input"
    input_dir.mkdir()
    
    # Copy test PDF to input directory with different names
    import shutil
    pdf1 = input_dir / "test1.pdf"
    pdf2 = input_dir / "test2.pdf"
    shutil.copy(TEST_PDF_PATH, pdf1)
    shutil.copy(TEST_PDF_PATH, pdf2)
    
    # Create output directory
    output_dir = tmp_path / "output"
    
    result = process_pdf(
        str(input_dir),
        "*.pdf",
        output_dir=str(output_dir),
        extract_text_flag=True
    )
    
    assert result.is_ok
    assert len(result.value) == 2  # Two output files
    
    # Check output structure
    for pdf_name in ["test1", "test2"]:
        pdf_dir = output_dir / pdf_name
        assert pdf_dir.is_dir()
        text_file = pdf_dir / f"{pdf_name}.txt"
        assert text_file.exists()
        assert text_file in result.value


def test_process_pdf_all_outputs(tmp_path, mock_dependencies, mock_subprocess_run):
    """Test extraction of all supported output formats.
    
    Comprehensive test of all extraction modes:
    1. Text extraction (.txt)
    2. Markdown conversion with tables (.md)
    3. Image extraction (.png)
    
    Verifies:
    - All output types are generated
    - Files are correctly organized in PDF-specific directory
    - Files follow expected naming conventions
    - PNG files are created for each page
    
    Directory structure created for test:
    input/
        test.pdf
    output/
        test/
            test.txt
            test.md
            test_page_1.png
            test_page_2.png
            ...
    """
    from pdf_processor.main import process_pdf
    
    # Create test input directory with sample PDF
    input_dir = tmp_path / "input"
    input_dir.mkdir()
    pdf_path = input_dir / "test.pdf"
    import shutil
    shutil.copy(TEST_PDF_PATH, pdf_path)
    
    # Create output directory
    output_dir = tmp_path / "output"
    
    result = process_pdf(
        str(input_dir),
        "test.pdf",
        output_dir=str(output_dir),
        extract_images_flag=True,
        extract_text_flag=True,
        extract_markdown_flag=True
    )
    
    assert result.is_ok
    
    # Check output structure
    pdf_dir = output_dir / "test"
    assert pdf_dir.is_dir()
    
    # Check file types
    extensions = {p.suffix for p in result.value}
    assert ".txt" in extensions
    assert ".md" in extensions
    assert ".png" in extensions
    
    # Verify file locations
    assert (pdf_dir / "test.txt") in result.value
    assert (pdf_dir / "test.md") in result.value
    # PNG files will have page numbers in their names


def test_process_pdf_pattern_matching(tmp_path, mock_dependencies, mock_subprocess_run):
    """Test PDF processing with glob pattern matching.
    
    Verifies the file pattern matching functionality:
    1. Processes only PDFs matching the pattern
    2. Ignores non-matching PDFs in same directory
    3. Creates output only for matched files
    
    Directory structure created for test:
    input/
        report1.pdf  (processed)
        report2.pdf  (processed)
        other.pdf    (ignored)
    output/
        report1/
            report1.txt
        report2/
            report2.txt
    
    Pattern: "report*.pdf" should match report1.pdf and report2.pdf,
    but not other.pdf.
    """
    from pdf_processor.main import process_pdf
    
    # Create test input directory with sample PDFs
    input_dir = tmp_path / "input"
    input_dir.mkdir()
    
    # Create PDFs with different names
    import shutil
    shutil.copy(TEST_PDF_PATH, input_dir / "report1.pdf")
    shutil.copy(TEST_PDF_PATH, input_dir / "report2.pdf")
    shutil.copy(TEST_PDF_PATH, input_dir / "other.pdf")
    
    result = process_pdf(
        str(input_dir),
        "report*.pdf",
        output_dir=str(tmp_path / "output"),
        extract_text_flag=True
    )
    
    assert result.is_ok
    assert len(result.value) == 2  # Only the two report PDFs
    assert all("report" in str(p) for p in result.value)


def test_process_pdf_with_errors(tmp_path, mock_dependencies, mock_subprocess_run):
    """Test graceful handling of mixed success/failure scenarios.
    
    Verifies that the processor:
    1. Continues processing after individual file failures
    2. Successfully processes valid PDFs
    3. Collects and reports errors
    4. Returns success if at least one file processed
    
    Directory structure created for test:
    input/
        valid.pdf     (good PDF, should process)
        invalid.pdf   (corrupt file, should fail)
    output/
        valid/
            valid.txt
    
    Expected behavior: Process should succeed overall, with warnings
    about the invalid PDF.
    """
    from pdf_processor.main import process_pdf
    
    # Create test input directory with sample PDFs
    input_dir = tmp_path / "input"
    input_dir.mkdir()
    
    # Create one valid and one invalid PDF
    import shutil
    shutil.copy(TEST_PDF_PATH, input_dir / "valid.pdf")
    (input_dir / "invalid.pdf").write_bytes(b"not a pdf")
    
    result = process_pdf(
        str(input_dir),
        "*.pdf",
        output_dir=str(tmp_path / "output"),
        extract_text_flag=True
    )
    
    # Should succeed with warnings
    assert result.is_ok
    assert len(result.value) == 1  # Only the valid PDF processed
    assert "valid" in str(result.value[0])


def test_process_pdf_invalid_output_dir():
    """Test handling of invalid output directory.
    
    Verifies error handling when the output directory:
    1. Doesn't exist
    2. Can't be created (e.g., insufficient permissions)
    3. Returns appropriate error message
    
    Expected behavior: Process should fail immediately with a
    directory-related error message.
    """
    from pdf_processor.main import process_pdf
    
    result = process_pdf(
        ".",
        "*.pdf",
        output_dir="/nonexistent/directory",
        extract_text_flag=True
    )
    
    assert not result.is_ok
    assert "directory" in str(result.error).lower()


def test_process_pdf_no_matching_files():
    """Test handling of no matching input files.
    
    Verifies error handling when:
    1. Input directory exists but contains no matching files
    2. Pattern doesn't match any files
    3. Returns appropriate error message
    
    Expected behavior: Process should fail with a "no matching files"
    error rather than silently succeeding with no output.
    """
    from pdf_processor.main import process_pdf
    
    result = process_pdf(
        ".",
        "nonexistent*.pdf",
        extract_text_flag=True
    )
    
    assert not result.is_ok
    assert "no files matching pattern" in str(result.error).lower()


def test_parse_args_check_dependencies():
    """Test parsing --check-dependencies flag."""
    from pdf_processor.main import parse_args
    args = parse_args(["--check-dependencies"])
    assert args.check_dependencies is True
    assert args.extract_text is False
    assert args.extract_markdown is False
    assert args.extract_images is False


def test_check_dependencies_success(monkeypatch):
    """Test dependency checking when all dependencies are installed."""
    # Mock successful dependency check
    def mock_check_deps():
        return Result.Ok(None)
    monkeypatch.setattr("pdf_processor.text.check_dependencies", mock_check_deps)
    
    # Should return True when dependencies are installed
    from pdf_processor.main import check_dependencies
    assert check_dependencies() is True


def test_check_dependencies_failure(monkeypatch):
    """Test dependency checking when dependencies are missing."""
    # Mock failed dependency check
    def mock_check_deps():
        return Result.Err(ExternalToolError("mutool", "Not found in PATH"))
    monkeypatch.setattr("pdf_processor.text.check_dependencies", mock_check_deps)
    
    # Should return False when dependencies are missing
    from pdf_processor.main import check_dependencies
    assert check_dependencies() is False


def test_main_check_dependencies(monkeypatch):
    """Test main function with --check-dependencies flag."""
    # Mock command line arguments
    monkeypatch.setattr("sys.argv", ["pdf-process", "--check-dependencies"])
    
    # Mock successful dependency check
    def mock_check_deps():
        return Result.Ok(None)
    monkeypatch.setattr("pdf_processor.text.check_dependencies", mock_check_deps)
    
    # Should return 0 when dependencies are installed
    from pdf_processor.main import main
    assert main() == 0


def test_main_missing_extraction_flags():
    """Test main function when no extraction flags are set."""
    from pdf_processor.main import parse_args
    args = parse_args([])  # No flags set
    assert args.extract_text is False
    assert args.extract_markdown is False
    assert args.extract_images is False
